---
title: 'Error Handling Best Practices'
description: 'Learn how to handle API errors effectively'
---

{/* # Error Handling Best Practices */}

This guide provides comprehensive best practices for handling errors in the Invaro API.

## Implementation Guide

### 1. Basic Error Handling

Always wrap API calls in try-catch blocks:

<CodeGroup>

```javascript JavaScript
try {
  const response = await client.processDocument(fileId);
  if (!response.success) {
    handleError(response.error);
    return;
  }
  // Process successful response
} catch (error) {
  // Handle network or unexpected errors
  handleUnexpectedError(error);
}
```

```python Python
try:
    response = client.process_document(file_id)
    if not response['success']:
        handle_error(response['error'])
        return
    # Process successful response
except Exception as error:
    # Handle network or unexpected errors
    handle_unexpected_error(error)
```

```php PHP
try {
    $response = $client->processDocument($fileId);
    if (!$response['success']) {
        handleError($response['error']);
        return;
    }
    // Process successful response
} catch (Exception $error) {
    // Handle network or unexpected errors
    handleUnexpectedError($error);
}
```

</CodeGroup>

### 2. Retry Mechanism

Implement a robust retry mechanism for transient errors:

<CodeGroup>

```javascript JavaScript
class RetryStrategy {
  constructor(maxRetries = 3, baseDelay = 1000) {
    this.maxRetries = maxRetries;
    this.baseDelay = baseDelay;
  }

  async execute(operation) {
    let lastError;
    
    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        
        if (!this.isRetryable(error)) {
          throw error;
        }
        
        const delay = this.calculateDelay(attempt, error);
        await this.wait(delay);
      }
    }
    
    throw lastError;
  }

  isRetryable(error) {
    return [429, 502, 503, 504].includes(error.status);
  }

  calculateDelay(attempt, error) {
    const retryAfter = error.response?.headers?.['retry-after'];
    if (retryAfter) {
      return parseInt(retryAfter) * 1000;
    }
    return this.baseDelay * Math.pow(2, attempt);
  }

  wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Usage
const retry = new RetryStrategy();
try {
  const result = await retry.execute(() => client.processDocument(fileId));
} catch (error) {
  console.error('All retry attempts failed:', error);
}
```

```python Python
class RetryStrategy:
    def __init__(self, max_retries=3, base_delay=1):
        self.max_retries = max_retries
        self.base_delay = base_delay

    def execute(self, operation):
        last_error = None
        
        for attempt in range(self.max_retries):
            try:
                return operation()
            except Exception as error:
                last_error = error
                
                if not self.is_retryable(error):
                    raise error
                
                delay = self.calculate_delay(attempt, error)
                time.sleep(delay)
        
        raise last_error

    def is_retryable(self, error):
        return hasattr(error, 'status') and error.status in [429, 502, 503, 504]

    def calculate_delay(self, attempt, error):
        retry_after = getattr(error, 'retry_after', None)
        if retry_after:
            return int(retry_after)
        return self.base_delay * (2 ** attempt)

# Usage
retry = RetryStrategy()
try:
    result = retry.execute(lambda: client.process_document(file_id))
except Exception as error:
    print('All retry attempts failed:', error)
```

</CodeGroup>

### 3. Error Logging

Implement comprehensive error logging:

```javascript
function logApiError(error, context = {}) {
  const errorLog = {
    timestamp: new Date().toISOString(),
    errorCode: error.code,
    message: error.message,
    requestId: error.requestId,
    endpoint: context.endpoint,
    parameters: context.parameters,
    stackTrace: error.stack,
    // Remove sensitive data
    ...sanitizeErrorData(context)
  };

  // Log to your monitoring system
  console.error('API Error:', errorLog);
  
  // Optional: Send to error tracking service
  if (process.env.SENTRY_DSN) {
    Sentry.captureException(error, {
      extra: errorLog
    });
  }
}
```

### 4. Rate Limit Handling

Implement a rate limit queue:

```javascript
class RateLimitQueue {
  constructor() {
    this.queue = [];
    this.processing = false;
  }

  async add(operation) {
    return new Promise((resolve, reject) => {
      this.queue.push({ operation, resolve, reject });
      if (!this.processing) {
        this.process();
      }
    });
  }

  async process() {
    if (this.queue.length === 0) {
      this.processing = false;
      return;
    }

    this.processing = true;
    const { operation, resolve, reject } = this.queue.shift();

    try {
      const result = await operation();
      resolve(result);
    } catch (error) {
      if (error.code === 'RATE_LIMIT_EXCEEDED') {
        const retryAfter = error.retry_after || 1;
        await new Promise(r => setTimeout(r, retryAfter * 1000));
        this.queue.unshift({ operation, resolve, reject });
      } else {
        reject(error);
      }
    }

    // Process next item
    this.process();
  }
}

// Usage
const queue = new RateLimitQueue();
const results = await Promise.all([
  queue.add(() => client.processDocument(file1)),
  queue.add(() => client.processDocument(file2))
]);
```

## Error Recovery Strategies

### 1. Circuit Breaker Pattern

Implement circuit breaker for failing endpoints:

```javascript
class CircuitBreaker {
  constructor(failureThreshold = 5, resetTimeout = 60000) {
    this.failureThreshold = failureThreshold;
    this.resetTimeout = resetTimeout;
    this.failures = 0;
    this.state = 'CLOSED';
    this.lastFailure = null;
  }

  async execute(operation) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailure >= this.resetTimeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await operation();
      if (this.state === 'HALF_OPEN') {
        this.state = 'CLOSED';
        this.failures = 0;
      }
      return result;
    } catch (error) {
      this.failures++;
      this.lastFailure = Date.now();
      
      if (this.failures >= this.failureThreshold) {
        this.state = 'OPEN';
      }
      
      throw error;
    }
  }
}
```

### 2. Fallback Mechanisms

Implement fallback strategies:

```javascript
async function processWithFallback(fileId) {
  try {
    // Try primary processing
    return await client.processDocument(fileId);
  } catch (error) {
    if (error.code === 'PROCESSING_ERROR') {
      // Try alternative processing method
      return await client.processDocumentLegacy(fileId);
    }
    throw error;
  }
}
```

## Monitoring and Alerting

### 1. Error Tracking

Set up comprehensive error tracking:

```javascript
class ErrorTracker {
  constructor() {
    this.errorCounts = new Map();
    this.alertThreshold = 10;
  }

  track(error) {
    const errorCode = error.code || 'UNKNOWN';
    const count = (this.errorCounts.get(errorCode) || 0) + 1;
    this.errorCounts.set(errorCode, count);

    if (count >= this.alertThreshold) {
      this.sendAlert(errorCode, count);
      this.errorCounts.set(errorCode, 0);
    }
  }

  sendAlert(errorCode, count) {
    // Implement your alerting logic
    console.error(`Alert: ${errorCode} occurred ${count} times`);
  }
}
```

### 2. Health Checks

Implement regular health checks:

```javascript
async function performHealthCheck() {
  try {
    const start = Date.now();
    await client.ping();
    const latency = Date.now() - start;

    return {
      status: 'healthy',
      latency,
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    return {
      status: 'unhealthy',
      error: error.message,
      timestamp: new Date().toISOString()
    };
  }
}
```

## Best Practices Summary

<Card>
  **Key Points**
  - Always implement proper error handling
  - Use retry mechanisms for transient errors
  - Implement rate limit handling
  - Set up proper logging and monitoring
  - Use circuit breakers for failing endpoints
  - Implement fallback mechanisms
  - Monitor error patterns
  - Perform regular health checks
</Card> 